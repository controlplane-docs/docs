---
title: Images
description: Build, push, pull, and manage container images with the Control Plane CLI.
---

The CLI provides powerful commands for working with container images. Build locally, push to your org's private registry, pull from external registries, and copy images between organizations.

## Quick reference

| Command | Description |
|---------|-------------|
| `cpln image build` | Build and optionally push images |
| `cpln image docker-login` | Authenticate Docker to your org's registry |
| `cpln image get` | List or view images in your org |
| `cpln image copy` | Copy images between organizations |
| `cpln image delete` | Delete images from your registry |

## Build and push images

The most common workflow is building and pushing a local application:

```bash
cpln image build --name my-app:v1 --push
```

This command:
1. Builds your image using the Dockerfile in the current directory
2. Tags it for your org's private registry
3. Pushes it to `your-org.registry.cpln.io/my-app:v1`

### Build options

<Tabs>
<Tab title="With Dockerfile">
  ```bash
  # Build from current directory
  cpln image build --name my-app:v1 --push

  # Specify a Dockerfile
  cpln image build --name my-app:v1 --dockerfile ./docker/Dockerfile.prod --push
  ```
</Tab>

<Tab title="With buildpacks">
  If you don't have a Dockerfile, the CLI can auto-detect your language and build with buildpacks:

  ```bash
  cpln image build --name my-app:v1 --push
  ```

  Use `--builder` to specify any CNB-compatible buildpack builder:

  ```bash
  cpln image build --name my-app:v1 --push --builder gcr.io/buildpacks/builder:google-22
  ```

  **Common builders:**

  | Builder | Description |
  |---------|-------------|
  | `heroku/builder:24` | Default. Supports Node.js, Python, Go, Java, Ruby, and more |
  | `gcr.io/buildpacks/builder:google-22` | Google Cloud buildpacks |
  | `paketobuildpacks/builder:base` | Paketo community buildpacks |

  <Info>
  Buildpacks require specific files to detect your language (e.g., `package.json` for Node.js, `requirements.txt` for Python). See [Buildpacks conventions](#buildpacks-conventions) for language-specific requirements.
  </Info>
</Tab>
</Tabs>

## Use images in workloads

Reference your pushed images when creating workloads:

```bash
cpln workload create --name my-app --gvc my-gvc \
  --image //image/my-app:v1 --port 8080 --public
```

### Image reference formats

| Format | Description |
|--------|-------------|
| `//image/IMAGE:TAG` | Image in your org's registry |
| `ORG.registry.cpln.io/IMAGE:TAG` | Image in another org's registry |
| `nginx:latest` | Public image from Docker Hub |
| `gcr.io/project/IMAGE:TAG` | Image from Google Container Registry |

## Authenticate Docker

For direct Docker operations, authenticate to your org's registry:

```bash
cpln image docker-login
```

Then use standard Docker commands:

```bash
docker pull your-org.registry.cpln.io/my-app:v1
docker push your-org.registry.cpln.io/my-app:v1
```

## List and manage images

```bash
# List all images in your org
cpln image get

# Get details for a specific image
cpln image get my-app:v1

# Delete an image
cpln image delete my-app:v1
```

## Copy images between orgs

Copy an image to another organization:

```bash
cpln image copy my-app:v1 --to-org destination-org
```

Copy with a different name:

```bash
cpln image copy my-app:v1 --to-org destination-org --to-name renamed-app:v1
```

<Info>
For cross-org copies with different credentials, use `--to-profile`. See the [Copy Images guide](/guides/copy-image).
</Info>

## CI/CD authentication

For automated pipelines, set `CPLN_TOKEN` in your CI/CD platform's secrets (e.g., GitLab CI/CD variables, GitHub secrets) and use the CLI directly:

```bash
cpln image build --name my-app:$CI_COMMIT_SHA --push
```

The CLI automatically uses `CPLN_TOKEN` when available.

For direct Docker access, authenticate with a service account:

```bash
echo $CPLN_TOKEN | docker login your-org.registry.cpln.io -u '<token>' --password-stdin
```

See [CI/CD Usage](/cli-reference/ci-cd-development/ci-cd) for complete automation setup.

## Buildpacks conventions

Buildpacks auto-detect your application language and build an optimized container image without a Dockerfile. The default builder is `heroku/builder:24`.

<Tip>
You can use any CNB-compatible builder image. Check [buildpacks.io](https://buildpacks.io/docs/) for more options or use a custom builder from your organization.
</Tip>

### Language conventions

The following conventions apply to the default `heroku/builder:24`. Other builders may have different requirements.

<AccordionGroup>
<Accordion title="Node.js">
  **Required files:**
  - `package.json` in the project root
  - `package-lock.json` in the project root

  <Warning>
  Run `npm install` before building to ensure `package-lock.json` is up to date with your dependencies.
  </Warning>

  **Start command:**
  - If `index.js` or `server.js` exists in the root, it will be used automatically
  - Otherwise, add a `scripts.start` command in `package.json`
  - Alternatively, create a `Procfile` in the project root

  **Example Procfile:**
  ```
  web: node src/app.js
  ```

  **Example package.json (with start script):**
  ```json
  {
    "name": "my-app",
    "scripts": {
      "start": "node src/app.js"
    },
    "engines": {
      "node": "20.x"
    }
  }
  ```

  **Example package.json (with index.js or server.js in root):**
  ```json
  {
    "name": "my-app",
    "engines": {
      "node": "20.x"
    }
  }
  ```

  <Tip>
  Specify your Node.js version in `engines.node` to ensure consistent builds.
  </Tip>
</Accordion>

<Accordion title="Python">
  **Detection (required - one of):**
  - `requirements.txt` (pip)
  - `uv.lock` (uv)
  - `poetry.lock` (Poetry)

  These files are used to detect a Python app and install dependencies.

  **Extra requirements:**
  - Using **uv** requires a `.python-version` file
  - Using **Poetry** for a non-packaged app requires `package-mode = false` in `pyproject.toml`

  **Start command (required for web apps):**
  - Create a `Procfile` in the project root
  - Python buildpacks do **not** auto-detect an entry file
  - Without a `Procfile`, the app may build but will not start

  **Example Procfile:**
  ```
  web: gunicorn -b 0.0.0.0:$PORT app:app
  ```

  **Runtime requirements:**
  - Server must bind to `0.0.0.0`
  - Server must listen on `$PORT`

  **Example requirements.txt:**
  ```
  flask==3.0.0
  gunicorn==21.2.0
  ```
</Accordion>

<Accordion title="Go">
  **Required files:**
  - `go.mod` in the project root

  **Project structure:**
  - The `main` package must be in the project root

  **Build behavior:**
  - Compiles the `main` package
  - Binary is automatically set as the start command

  **Example go.mod:**
  ```
  module github.com/myorg/myapp

  go 1.21
  ```
</Accordion>

<Accordion title="Java (Maven)">
  **Required files:**
  - `pom.xml` in the project root

  **Build behavior:**
  - Runs `mvn package`

  **Start command:**
  - Spring Boot JARs: start command is auto-detected
  - Non-Spring executable JARs: add a `Procfile` (recommended)

  **Runtime requirements:**
  - Server must bind to `0.0.0.0`
  - Server must listen on `$PORT`

  <Tip>
  If you need a specific JDK version, pin it explicitly (otherwise the builder default may be used).
  </Tip>

  **Example pom.xml excerpt (Spring Boot):**
  ```xml
  <packaging>jar</packaging>
  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
  ```
</Accordion>

<Accordion title="Java (Gradle)">
  **Required files:**
  - `build.gradle` or `build.gradle.kts` in the project root
  - `gradlew` (Gradle Wrapper) in the project root

  **Build behavior:**
  - Runs `./gradlew build`

  **Start command:**
  - Spring Boot JARs: start command is auto-detected
  - Non-Spring executable JARs: add a `Procfile` (recommended)

  **Runtime requirements:**
  - Server must bind to `0.0.0.0`
  - Server must listen on `$PORT`

  <Tip>
  If you need a specific Java version, add `system.properties` (e.g. `java.runtime.version=21`).
  Avoid Gradle toolchains unless you configure toolchain downloads.
  </Tip>
</Accordion>

<Accordion title="Ruby">
  **Required files:**
  - `Gemfile` and `Gemfile.lock` in the project root

  **Start command:**
  - Rails apps: default start command exists, but a `Procfile` is recommended
  - Non-Rails apps: create a `Procfile` with `web: <command>`

  **Runtime requirements:**
  - Server must listen on `$PORT`

  **Example Procfile (non-Rails):**
  ```
  web: bundle exec puma -p $PORT config.ru
  ```

  **Example Procfile (Rails with Puma):**
  ```
  web: bundle exec puma -C config/puma.rb
  ```
</Accordion>

<Accordion title="PHP">
  **Required files:**
  - `composer.json` and `composer.lock` in the project root

  **Start command:**
  - Create a `Procfile` with `web: <command>`

  **Example Procfile (Apache):**
  ```
  web: heroku-php-apache2 public/
  ```
</Accordion>
</AccordionGroup>

### The Procfile

A `Procfile` defines how your application is started by the platform. Place it in the project root.

```
web: <start-command>
```

**Notes:**

- Some languages auto-detect a start command (e.g., Go binaries, Spring Boot JARs).
- Other languages require a `Procfile` to start a web server.
- Refer to the language-specific sections above for exact requirements.

## Troubleshooting

<AccordionGroup>
<Accordion title="unknown shorthand flag: 'f' in -f">
  Docker Buildx is not installed. Install it:

  ```bash
  curl -sSL "https://github.com/docker/buildx/releases/download/v0.29.1/buildx-v0.29.1.linux-amd64" \
    | install -m 0755 -D /dev/stdin ~/.docker/cli-plugins/docker-buildx
  ```
</Accordion>

<Accordion title="Authentication failed or 403">
  Re-run `cpln image docker-login` to refresh credentials and double check that you don't have typos in the org name.
</Accordion>

<Accordion title="Push denied">
  Verify you have push permission on images. Check your policies or refresh your service account token.
</Accordion>

<Accordion title="Image too large">
  Optimize your Dockerfile:
  - Use multi-stage builds
  - Start from smaller base images
  - Remove unnecessary files
</Accordion>

<Accordion title="Buildpack: Container starts but crashes immediately">
  The buildpack built your image but doesn't know how to start it. Common causes:

  1. **Missing Procfile**: Create a `Procfile` in your project root:
     ```
     web: <your-start-command>
     ```

  2. **Missing start script (Node.js)**: Add a `start` script to `package.json`:
     ```json
     "scripts": {
       "start": "node server.js"
     }
     ```

  3. **Wrong port**: Your app must listen on the `$PORT` environment variable, not a hardcoded port.
</Accordion>
</AccordionGroup>

## Learn more

<CardGroup cols={2}>
  <Card title="Push Images" href="/guides/push-image" icon="upload">
    Detailed guide for building and pushing images
  </Card>
  <Card title="Pull Images" href="/guides/pull-image" icon="download">
    Configure workloads to pull from private registries
  </Card>
  <Card title="Copy Images" href="/guides/copy-image" icon="copy">
    Copy images between organizations
  </Card>
  <Card title="Image Command Reference" href="/cli-reference/commands/image" icon="book">
    Full command documentation
  </Card>
</CardGroup>
